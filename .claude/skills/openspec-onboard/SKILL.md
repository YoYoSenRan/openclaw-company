---
name: openspec-onboard
description: OpenSpec 引导式入门 - 带有讲解和真实代码库工作的完整工作流周期演练。
license: MIT
compatibility: 需要 openspec CLI。
metadata:
  author: openspec
  version: "1.0"
  generatedBy: "1.1.1"
---

引导用户完成他们的第一个完整 OpenSpec 工作流周期。这是一个教学体验——你将在他们的代码库中做实际工作，同时解释每一步。

---

## 预检

开始之前，检查 OpenSpec 是否已初始化：

```bash
openspec status --json 2>&1 || echo "NOT_INITIALIZED"
```

**如果未初始化：**
> OpenSpec 尚未在此项目中设置。先运行 `openspec init`，然后回来使用 `/opsx:onboard`。

如果未初始化，在此停止。

---

## 阶段 1：欢迎

显示：

```
## 欢迎使用 OpenSpec！

我将引导你完成一个完整的变更周期——从想法到实现——使用你代码库中的真实任务。在此过程中，你将通过实践学习工作流。

**我们将要做的事情：**
1. 在你的代码库中选择一个小而真实的任务
2. 简要探索问题
3. 创建一个变更（我们工作的容器）
4. 构建工件：proposal → specs → design → tasks
5. 实现任务
6. 归档已完成的变更

**时间：**约 15-20 分钟

让我们从找点事情开始吧。
```

---

## 阶段 2：任务选择

### 代码库分析

扫描代码库以寻找小的改进机会。查找：

1. **TODO/FIXME 注释** - 在代码文件中搜索 `TODO`、`FIXME`、`HACK`、`XXX`
2. **缺失的错误处理** - 吞掉错误的 `catch` 块，没有 try-catch 的风险操作
3. **没有测试的函数** - 将 `src/` 与测试目录交叉引用
4. **类型问题** - TypeScript 文件中的 `any` 类型（`: any`、`as any`）
5. **调试残留** - 非调试代码中的 `console.log`、`console.debug`、`debugger` 语句
6. **缺失的验证** - 没有验证的用户输入处理器

还要检查最近的 git 活动：
```bash
git log --oneline -10 2>/dev/null || echo "没有 git 历史"
```

### 展示建议

根据你的分析，展示 3-4 个具体建议：

```
## 任务建议

基于扫描你的代码库，这里有一些不错的入门任务：

**1. [最有前景的任务]**
   位置：`src/path/to/file.ts:42`
   范围：约 1-2 个文件，约 20-30 行
   为什么好：[简要原因]

**2. [第二个任务]**
   位置：`src/another/file.ts`
   范围：约 1 个文件，约 15 行
   为什么好：[简要原因]

**3. [第三个任务]**
   位置：[location]
   范围：[estimate]
   为什么好：[简要原因]

**4. 其他？**
   告诉我你想做什么。

你对哪个任务感兴趣？（选择一个数字或描述你自己的）
```

**如果没找到：** 回退到询问用户想要构建什么：
> 我没有在你的代码库中找到明显的快速收获。你一直想做或修复什么小事？

### 范围边界

如果用户选择或描述了太大的内容（主要功能、多天工作）：

```
那是一个有价值的任务，但对于你的第一次 OpenSpec 演练来说可能太大了。

为了学习工作流，越小越好——它让你可以看到完整的周期而不会陷入实现细节。

**选项：**
1. **切分得更小** - [他们的任务] 最小的有用部分是什么？也许只是 [specific slice]？
2. **选择其他** - 其他建议中的一个，或不同的小任务？
3. **仍然要做** - 如果你真的想处理这个，我们可以。只是知道这会花更长时间。

你更倾向于什么？
```

如果用户坚持，让他们覆盖——这是一个软边界。

---

## 阶段 3：探索演示

一旦选择了任务，简要演示探索模式：

```
在我们创建变更之前，让我快速向你展示**探索模式**——这是在承诺方向之前思考问题的方式。
```

花 1-2 分钟调查相关代码：
- 读取涉及的文件
- 如果有帮助，画一个快速的 ASCII 图
- 注意任何考虑事项

```
## 快速探索

[你的简要分析——你发现了什么，任何考虑事项]

┌─────────────────────────────────────────┐
│   [可选：如果有帮助的 ASCII 图]          │
└─────────────────────────────────────────┘

探索模式（`/opsx:explore`）就是这种思考——在实现之前进行调查。你可以在需要思考问题时随时使用它。

现在让我们创建一个变更来承载我们的工作。
```

**暂停** - 在继续之前等待用户确认。

---

## 阶段 4：创建变更

**讲解：**
```
## 创建变更

OpenSpec 中的"变更"是一部分工作周围所有思考和规划的容器。它位于 `openspec/changes/<name>/` 中，保存你的工件——proposal、specs、design、tasks。

让我为我们的任务创建一个。
```

**执行：** 使用派生的 kebab-case 名称创建变更：
```bash
openspec new change "<derived-name>"
```

**展示：**
```
已创建：`openspec/changes/<name>/`

文件夹结构：
```
openspec/changes/<name>/
├── proposal.md    ← 我们为什么做这个（空，我们要填充它）
├── design.md      ← 我们将如何构建它（空）
├── specs/         ← 详细需求（空）
└── tasks.md       ← 实现检查清单（空）
```

现在让我们填写第一个工件——proposal。
```

---

## 阶段 5：Proposal

**讲解：**
```
## Proposal

proposal 捕获我们**为什么**进行此变更以及高级层面上涉及**什么**。它是工作的"电梯演讲"。

我将根据我们的任务起草一个。
```

**执行：** 起草 proposal 内容（暂不保存）：

```
这是 draft proposal：

---

## Why

[1-2 句解释问题/机会]

## What Changes

[将要改变什么的要点]

## Capabilities

### New Capabilities
- `<capability-name>`：[简要描述]

### Modified Capabilities
<!-- 如果修改现有行为 -->

## Impact

- `src/path/to/file.ts`：[什么改变]
- [其他文件如果适用]

---

这是否捕捉了意图？我可以在保存前调整。
```

**暂停** - 等待用户批准/反馈。

批准后，保存 proposal：
```bash
openspec instructions proposal --change "<name>" --json
```
然后将内容写入 `openspec/changes/<name>/proposal.md`。

```
Proposal 已保存。这是你的"为什么"文档——你可以随时回来完善它，因为理解在发展。

接下来：specs。
```

---

## 阶段 6：Specs

**讲解：**
```
## Specs

specs 以精确、可测试的术语定义我们要构建**什么**。它们使用需求/场景格式，使预期行为清晰明了。

对于像这样的小任务，我们可能只需要一个 spec 文件。
```

**执行：** 创建 spec 文件：
```bash
mkdir -p openspec/changes/<name>/specs/<capability-name>
```

起草 spec 内容：

```
这是 spec：

---

## ADDED Requirements

### Requirement: <Name>

<系统应该做什么的描述>

#### Scenario: <Scenario name>

- **WHEN** <trigger condition>
- **THEN** <expected outcome>
- **AND** <additional outcome if needed>

---

这种格式——WHEN/THEN/AND——使需求可测试。你实际上可以将它们作为测试用例阅读。
```

保存到 `openspec/changes/<name>/specs/<capability>/spec.md`。

---

## 阶段 7：Design

**讲解：**
```
## Design

design 捕获我们将**如何**构建它——技术决策、权衡、方法。

对于小的变更，这可能很简短。没关系——不是每个变更都需要深入的设计讨论。
```

**执行：** 起草 design.md：

```
这是 design：

---

## Context

[关于当前状态的简要上下文]

## Goals / Non-Goals

**Goals:**
- [我们试图实现什么]

**Non-Goals:**
- [明确不在范围内什么]

## Decisions

### Decision 1: [关键决策]

[方法解释和理由]

---

对于小任务，这捕获了关键决策而不过度工程化。
```

保存到 `openspec/changes/<name>/design.md`。

---

## 阶段 8：Tasks

**讲解：**
```
## Tasks

最后，我们将工作分解为实现任务——驱动应用阶段的复选框。

这些应该小、清晰、按逻辑顺序排列。
```

**执行：** 根据 specs 和 design 生成任务：

```
这是实现任务：

---

## 1. [类别或文件]

- [ ] 1.1 [具体任务]
- [ ] 1.2 [具体任务]

## 2. 验证

- [ ] 2.1 [验证步骤]

---

每个复选框成为应用阶段的一个工作单元。准备实现？
```

**暂停** - 等待用户确认他们准备好实现。

保存到 `openspec/changes/<name>/tasks.md`。

---

## 阶段 9：Apply（实现）

**讲解：**
```
## 实现

现在我们实现每个任务，边做边勾选它们。我会宣布每一个，偶尔说明 specs/design 如何影响方法。
```

**执行：** 对于每个任务：

1. 宣布："正在处理任务 N：[description]"
2. 在代码库中实现更改
3. 自然地引用 specs/design："spec 说 X，所以我做 Y"
4. 在 tasks.md 中标记完成：`- [ ]` → `- [x]`
5. 简要状态："✓ 任务 N 完成"

保持讲解轻松——不要过度解释每一行代码。

所有任务完成后：

```
## 实现完成

所有任务已完成：
- [x] 任务 1
- [x] 任务 2
- [x] ...

变更已实现！还有一步——让我们归档它。
```

---

## 阶段 10：Archive

**讲解：**
```
## 归档

当变更完成时，我们归档它。这会将其从 `openspec/changes/` 移动到 `openspec/changes/archive/YYYY-MM-DD-<name>/`。

已归档的变更成为你项目的决策历史——你可以随时找到它们，了解为什么以某种方式构建了某些东西。
```

**执行：**
```bash
openspec archive "<name>"
```

**展示：**
```
已归档到：`openspec/changes/archive/YYYY-MM-DD-<name>/`

变更现在是你项目历史的一部分。代码在你的代码库中，决策记录已保存。
```

---

## 阶段 11：回顾与下一步

```
## 恭喜！

你刚刚完成了一个完整的 OpenSpec 周期：

1. **Explore** - 思考问题
2. **New** - 创建变更容器
3. **Proposal** - 捕捉 WHY
4. **Specs** - 详细定义 WHAT
5. **Design** - 决定 HOW
6. **Tasks** - 分解为步骤
7. **Apply** - 实现工作
8. **Archive** - 保存记录

同样的节奏适用于任何大小的变更——小的修复或主要功能。

---

## 命令参考

| 命令 | 作用 |
|-----|------|
| `/opsx:explore` | 在工作之前/期间思考问题 |
| `/opsx:new` | 开始新变更，逐步处理工件 |
| `/opsx:ff` | 快速前进：一次性创建所有工件 |
| `/opsx:continue` | 继续处理现有变更 |
| `/opsx:apply` | 从变更实现任务 |
| `/opsx:verify` | 验证实现是否匹配工件 |
| `/opsx:archive` | 归档已完成的变更 |

---

## 下一步？

在你想实际构建的东西上尝试 `/opsx:new` 或 `/opsx:ff`。你已经掌握了节奏！
```

---

## 优雅退出处理

### 用户想中途停止

如果用户说他们需要停止、想暂停或似乎不感兴趣：

```
没问题！你的变更保存在 `openspec/changes/<name>/`。

稍后继续：
- `/opsx:continue <name>` - 恢复工件创建
- `/opsx:apply <name>` - 跳到实现（如果任务存在）

工作不会丢失。随时回来。
```

优雅退出，不施加压力。

### 用户只想要命令参考

如果用户说他们只想看命令或跳过教程：

```
## OpenSpec 快速参考

| 命令 | 作用 |
|-----|------|
| `/opsx:explore` | 思考问题（无代码更改） |
| `/opsx:new <name>` | 开始新变更，逐步处理 |
| `/opsx:ff <name>` | 快速前进：一次性创建所有工件 |
| `/opsx:continue <name>` | 继续现有变更 |
| `/opsx:apply <name>` | 实现任务 |
| `/opsx:verify <name>` | 验证实现 |
| `/opsx:archive <name>` | 完成后归档 |

尝试 `/opsx:new` 开始你的第一个变更，或 `/opsx:ff` 如果你想快速移动。
```

优雅退出。

---

## 边界规则

- **在关键转换时遵循 讲解 → 执行 → 展示 → 暂停 模式**（探索后、proposal 草稿后、tasks 后、archive 后）
- **实现期间保持讲解轻松**——教学而不是说教
- **不要跳过阶段**，即使变更很小——目标是教授工作流
- **在标记的点上暂停确认**，但不要过度暂停
- **优雅处理退出**——永远不要向用户施压继续
- **使用真实的代码库任务**——不要模拟或使用虚假示例
- **温和地调整范围**——引导向较小的任务但尊重用户选择

