---
name: "OPSX: Verify"
description: 在归档前验证实现是否与变更工件匹配
category: Workflow
tags: [workflow, verify, experimental]
---

验证实现是否与变更工件（specs、tasks、design）匹配。

**输入**：可选择在 `/opsx:verify` 后指定一个变更名称（例如 `/opsx:verify add-auth`）。如果省略，检查是否可以从对话上下文中推断。如果模糊或不明确，你必须提示用户选择可用的变更。

**步骤**

1. **如果未提供变更名称，提示选择**

   运行 `openspec list --json` 获取可用变更。使用 **AskUserQuestion 工具** 让用户选择。

   显示具有实现任务的变更（存在 tasks 工件）。
   如果可用，包括每个变更使用的模式。
   将有未完成任务的变更标记为"（进行中）"。

   **重要**：不要猜测或自动选择变更。始终让用户选择。

2. **检查状态以了解模式**
   ```bash
   openspec status --change "<name>" --json
   ```
   解析 JSON 以了解：
   - `schemaName`：正在使用的工作流（例如 "spec-driven"）
   - 此变更存在哪些工件

3. **获取变更目录并加载工件**

   ```bash
   openspec instructions apply --change "<name>" --json
   ```

   这返回变更目录和上下文文件。从 `contextFiles` 读取所有可用的工件。

4. **初始化验证报告结构**

   创建包含三个维度的报告结构：
   - **完整性**：跟踪任务和规格覆盖
   - **正确性**：跟踪需求实现和场景覆盖
   - **一致性**：跟踪设计遵循和模式一致性

   每个维度可以有 CRITICAL、WARNING 或 SUGGESTION 级别的问题。

5. **验证完整性**

   **任务完成情况**：
   - 如果 tasks.md 存在于 contextFiles 中，读取它
   - 解析复选框：`- [ ]`（未完成）和 `- [x]`（已完成）
   - 统计已完成与总任务数
   - 如果存在未完成的任务：
     - 为每个未完成的任务添加 CRITICAL 问题
     - 建议："完成任务：<description>" 或 "如果已实现则标记为完成"

   **规格覆盖**：
   - 如果 `openspec/changes/<name>/specs/` 中存在增量规格：
     - 提取所有需求（标记为 "### Requirement:"）
     - 对于每个需求：
       - 在代码库中搜索与需求相关的关键词
       - 评估实现是否可能存在
     - 如果需求似乎未实现：
       - 添加 CRITICAL 问题："未找到需求：<requirement name>"
       - 建议："实现需求 X：<description>"

6. **验证正确性**

   **需求实现映射**：
   - 对于增量规格中的每个需求：
     - 在代码库中搜索实现证据
     - 如果找到，记录文件路径和行范围
     - 评估实现是否匹配需求意图
     - 如果检测到偏离：
       - 添加 WARNING："实现可能与规格偏离：<details>"
       - 建议："根据需求 X 检查 <file>:<lines>"

   **场景覆盖**：
   - 对于增量规格中的每个场景（标记为 "#### Scenario:"）：
     - 检查代码中是否处理了条件
     - 检查是否存在覆盖该场景的测试
     - 如果场景似乎未被覆盖：
       - 添加 WARNING："场景未被覆盖：<scenario name>"
       - 建议："为场景添加测试或实现：<description>"

7. **验证一致性**

   **设计遵循**：
   - 如果 design.md 存在于 contextFiles 中：
     - 提取关键决策（查找 "Decision:"、"Approach:"、"Architecture:" 等部分）
     - 验证实现是否遵循这些决策
     - 如果检测到矛盾：
       - 添加 WARNING："未遵循设计决策：<decision>"
       - 建议："更新实现或修改 design.md 以匹配实际情况"
   - 如果没有 design.md：跳过设计遵循检查，注明"没有 design.md 可对照验证"

   **代码模式一致性**：
   - 审查新代码是否与项目模式一致
   - 检查文件命名、目录结构、编码风格
   - 如果发现显著偏离：
     - 添加 SUGGESTION："代码模式偏离：<details>"
     - 建议："考虑遵循项目模式：<example>"

8. **生成验证报告**

   **摘要记分卡**：
   ```
   ## 验证报告：<change-name>

   ### 摘要
   | 维度     | 状态            |
   |---------|-----------------|
   | 完整性  | X/Y 任务，N 个需求|
   | 正确性  | M/N 需求已覆盖  |
   | 一致性  | 已遵循/有问题   |
   ```

   **按优先级列出问题**：

   1. **CRITICAL**（归档前必须修复）：
      - 未完成的任务
      - 缺失的需求实现
      - 每个都有具体、可操作的建议

   2. **WARNING**（应该修复）：
      - 规格/设计偏离
      - 缺失的场景覆盖
      - 每个都有具体的建议

   3. **SUGGESTION**（建议修复）：
      - 模式不一致
      - 小改进
      - 每个都有具体的建议

   **最终评估**：
   - 如果有 CRITICAL 问题："发现 X 个严重问题。归档前请修复。"
   - 如果只有警告："没有严重问题。有 Y 个警告需要考虑。可以归档（带有已记录的改进）。"
   - 如果全部通过："所有检查通过。准备归档。"

**验证启发式规则**

- **完整性**：关注客观的检查清单项（复选框、需求列表）
- **正确性**：使用关键词搜索、文件路径分析、合理推断 - 不需要完美的确定性
- **一致性**：寻找明显的矛盾，不要挑剔风格
- **误报**：当不确定时，优先选择 SUGGESTION 而非 WARNING，WARNING 而非 CRITICAL
- **可操作性**：每个问题必须有具体的建议，尽可能带有文件/行引用

**优雅降级**

- 如果只有 tasks.md 存在：仅验证任务完成情况，跳过规格/设计检查
- 如果 tasks + specs 存在：验证完整性和正确性，跳过设计
- 如果有完整工件：验证所有三个维度
- 始终注明跳过了哪些检查以及原因

**输出格式**

使用清晰的 markdown：
- 摘要记分卡使用表格
- 问题使用分组列表（CRITICAL/WARNING/SUGGESTION）
- 代码引用格式：`file.ts:123`
- 具体、可操作的建议
- 不要像"考虑审查"这样的模糊建议

